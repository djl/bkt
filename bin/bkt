#!/usr/bin/env python
"""
Usage: bkt <command> [options]

bkt handles file uploads to S3.

Commands:
  ls             List all buckets or all files in a bucket
  get            Download a file from a bucket
  mk             Create a new bucket
  rm             Delete a bucket or a file from a bucket
  put            Upload a file to a bucket

Options:
  -h, --help     Print this message and exit
"""
import ConfigParser
import os
import optparse
import re
import subprocess
import sys
import textwrap

from boto.exception import S3CreateError, S3ResponseError
from boto.s3.connection import Location, S3Connection
from boto.s3.key import Key

try:
    import progressbar
    HAS_PROGRESSBAR = True
except ImportError:
    HAS_PROGRESSBAR = False


def sizeof(num):
    for x in ['bytes','KB','MB','GB','TB']:
        if num < 1024.0:
            return "%3.1f%s" % (num, x)
        num /= 1024.0


class Command(object):
    message_width = 79
    location = Location.DEFAULT

    def __init__(self):
        self.setup_config()
        self.setup_auth()
        self.setup_connection()
        self.setup_location()
        self.setup_parser()

    def setup_auth(self):
        self.access_key = None
        self.secret_key = None

        for option in ['access_key', 'secret_key']:
            # try to get the regular options
            if self.config.has_option('auth', option):
                value = self.config.get('auth', option)
                setattr(self, option, value)

            # try to get the `_eval` option
            if self.config.has_option('auth', option + '_eval'):
                value = self.eval_option(self.config.get('auth', option + '_eval'))
                setattr(self, option, value)

            if getattr(self, option, None) is None:
                self.error("Couldn't read option '%s' in your ~/.bkt file." % option)

    def setup_config(self):
        self.config = ConfigParser.ConfigParser()
        self.config_file = os.path.expanduser('~/.bkt')

        try:
            self.config.readfp(open(self.config_file))
        except IOError:
            self.error("Couldn't read your ~/.bkt file.")

    def setup_connection(self):
        self.conn = S3Connection(self.access_key, self.secret_key)

    def setup_location(self):
        try:
            location = self.config.get('buckets', 'location')
            if not hasattr(Location, location):
                self.error("Unknown location '%s' " % location)
            self.location = getattr(Location, location)
        except ConfigParser.Error:
            self.location = Location.DEFAULT

    def setup_parser(self):
        self.parser = optparse.OptionParser()
        self.parser.remove_option('--help')
        self.parser.add_option('-h', '--help',
                               action='callback',
                               callback=self.help)

    def eval_option(self, cmd):
        proc = subprocess.Popen(cmd.split(), stdout=subprocess.PIPE)
        return proc.communicate()[0].strip()

    def error(self, msg):
        print >> sys.stderr, '\n'.join(textwrap.wrap(msg, self.message_width))
        sys.exit(1)

    def help(self, *args, **kwargs):
        """
        Prints the help message to stderr.
        """
        output = ""
        for line in self.__doc__.strip().split("\n"):
            output += re.sub('^\s{4}', '', line) + "\n"
        print >> sys.stderr, 'Usage: %s' % output.strip()
        sys.exit()

    def main(self):
        self.options, self.args = self.parser.parse_args(sys.argv[2:])
        self.run()

    def start_progressbar(self, filename, size):
        if not HAS_PROGRESSBAR:
            return
        widgets = [
            filename, ' ', progressbar.Bar(), ' ',
            progressbar.FileTransferSpeed(), ' | ', progressbar.Percentage(),
            ' ',  progressbar.ETA()
        ]
        self.progressbar = progressbar.ProgressBar(widgets=widgets, maxval=size)
        self.progressbar.start()

    def finish_progressbar(self):
        if HAS_PROGRESSBAR:
            self.progressbar.finish()

    def progress(self, current, total):
        if HAS_PROGRESSBAR:
            self.progressbar.update(current)


class CreateCommand(Command):
    """
    bkt create [options] <bucket>

    Creates a new bucket.

    Options:
        -l, --location LOC       The location in which to create the bucket
    """
    name = 'create'
    alias = ('mk',)

    def __init__(self):
        super(CreateCommand, self).__init__()

        # custom --location option
        self.parser.add_option('-l', '--location', dest='location',
                               default=self.location)

    def run(self):
        if len(self.args) != 1:
            self.help()

        try:
            self.conn.create_bucket(self.args[0], location=self.options.location)
        except (S3CreateError, S3ResponseError), e:
            self.error(e.error_message)


class GetCommand(Command):
    """
    bkt get <bucket> <file>

    Get a file from a bucket.
    """
    name = 'get'

    def run(self):
        if len(self.args) not in (2, 3):
            self.help()

        try:
            bucket = self.conn.get_bucket(self.args[0])
        except S3ResponseError, e:
            self.error(e.error_message)

        key = bucket.get_key(self.args[1])
        if not key:
            self.error("The specified file does not exist in this bucket")

        try:
            self.start_progressbar(self.args[1], key.size)
            fn = os.path.join(os.getcwd(), self.args[1])
            fh = open(fn, 'w')
            key.get_file(fh, cb=self.progress, num_cb=100)
            self.finish_progressbar()
        except IOError:
            self.error("Could not write to local file '%s'" % fn)


class LsCommand(Command):
    """
    bkt ls [options] [<bucket>]

    Lists all the buckets or all files in a given bucket.

    Options:
      -v, --verbose          Display more information about each bucket
    """
    name = 'ls'
    alias = ('list',)

    def __init__(self):
        super(LsCommand, self).__init__()
        self.parser.add_option('-a', '-v', '--verbose',
                               action='store_true', dest='verbose')

    def run(self):
        if len(self.args) not in (0, 1):
            self.help()

        # listing all buckets
        if len(self.args) == 0:
            buckets = self.conn.get_all_buckets()
            for b in buckets:
                if not self.options.verbose:
                    print b.name
                else:
                    print '%s %s' % (b.name, b.get_location() or "DEFAULT")
        else:
            try:
                bucket = self.conn.get_bucket(self.args[0])
                for key in bucket.list():
                    if not self.options.verbose:
                        print key.name
                    else:
                        print key.name
                        print ' %s' % sizeof(key.size)
                        print ' %s' % ', '.join([x.permission for x in key.get_acl().acl.grants])
            except S3ResponseError, e:
                self.error(e.error_message)


class RmCommand(Command):
    """
    bkt rm <bucket> [<file>]

    Deletes a bucket or a file from a bucket.
    """
    name = 'rm'

    def run(self):
        if len(self.args) not in (1, 2):
            self.help()

        try:
            bucket = self.conn.get_bucket(self.args[0])
            if len(self.args) == 1:
                self.conn.delete_bucket(bucket)
            else:
                bucket.delete_key(self.args[1])
        except S3ResponseError, e:
            self.error(e.error_message)


class PutCommand(Command):
    """
    bkt put <bucket> <file>

    Uploads a new file to a bucket.
    """
    name = 'put'

    def run(self):
        if len(self.args) != 2:
            self.help()

        try:
            size = os.stat(self.args[1]).st_size
            bucket = self.conn.get_bucket(self.args[0])
            key = Key(bucket)
            key.name = os.path.basename(self.args[1])
            self.start_progressbar(self.args[1], size)
            key.set_contents_from_filename(self.args[1], cb=self.progress, num_cb=100)
            self.finish_progressbar()
        except S3ResponseError, e:
            self.error(e.error_message)


if __name__ == '__main__':
    # no commands or arguments, print the help message
    if len(sys.argv) <= 1 or sys.argv[1] in ('-h', '--help', 'help'):
        print >> sys.stderr, __doc__.strip()
        sys.exit()

    for c in Command.__subclasses__():
        if c.name == sys.argv[1] or hasattr(c, 'alias') and sys.argv[1] in c.alias:
            command = c()
            command.main()
            sys.exit()

    print >> sys.stderr, "Unknown command '%s'." % sys.argv[1]
    sys.exit(1)
