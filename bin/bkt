#!/usr/bin/env python
"""
Usage: bkt <command> [options]

bkt handles file uploads to S3.

Commands:
  ls             List all buckets or all files in a bucket
  get            Download a file from a bucket
  mk             Create a new bucket
  put            Upload a file to a bucket
  cp             Copy files between buckets
  mv             Move files between buckets
  rm             Delete a bucket or a file from a bucket

Options:
  -h, --help     Print this message and exit
"""
import os
import optparse
import re
import subprocess
import sys
import textwrap

try:
    import configparser
except ImportError:
    import ConfigParser as configparser

from boto.exception import S3CreateError, S3ResponseError
from boto.s3.connection import Location, S3Connection
from boto.s3.key import Key

try:
    import progressbar
    HAS_PROGRESSBAR = True
except ImportError:
    HAS_PROGRESSBAR = False


def sizeof(num):
    for x in ['bytes','KB','MB','GB','TB']:
        if num < 1024.0:
            return "%3.1f%s" % (num, x)
        num /= 1024.0


class Command(object):
    message_width = 79
    location = Location.DEFAULT

    def __init__(self):
        self.setup_config()
        self.setup_auth()
        self.setup_connection()
        self.setup_location()
        self.setup_parser()

    def setup_auth(self):
        self.access_key = None
        self.secret_key = None

        for option in ['access_key', 'secret_key']:
            # try to get the regular options
            if self.config.has_option('auth', option):
                value = self.config.get('auth', option)
                setattr(self, option, value)

            # try to get the `_eval` option
            if self.config.has_option('auth', option + '_eval'):
                value = self.eval_option(self.config.get('auth', option + '_eval'))
                setattr(self, option, value)

            if getattr(self, option, None) is None:
                self.error("Couldn't read option '%s' in your ~/.bkt file." % option)

    def setup_config(self):
        self.config = configparser.ConfigParser()
        self.config_file = os.path.expanduser('~/.bkt')

        try:
            self.config.readfp(open(self.config_file))
        except IOError:
            self.error("Couldn't read your ~/.bkt file.")

    def setup_connection(self):
        self.conn = S3Connection(self.access_key, self.secret_key)

    def setup_location(self):
        try:
            location = self.config.get('buckets', 'location')
            if not hasattr(Location, location):
                self.error("Unknown location '%s' " % location)
            self.location = getattr(Location, location)
        except configparser.Error:
            self.location = Location.DEFAULT

    def setup_parser(self):
        self.parser = optparse.OptionParser()
        self.parser.remove_option('--help')
        self.parser.add_option('-h', '--help',
                               action='callback',
                               callback=self.help)

    def eval_option(self, cmd):
        proc = subprocess.Popen(cmd.split(), stdout=subprocess.PIPE)
        return proc.communicate()[0].strip()

    def error(self, msg):
        msg = '\n'.join(textwrap.wrap(msg, self.message_width))
        sys.stderr.write(msg + '\n')
        sys.exit(1)

    def help(self, *args, **kwargs):
        """
        Prints the help message to stderr.
        """
        output = ""
        for line in self.__doc__.strip().split("\n"):
            output += re.sub('^\s{4}', '', line) + "\n"
        sys.stderr.write('Usage: %s\n' % output.strip())
        sys.exit()

    def main(self):
        self.options, self.args = self.parser.parse_args(sys.argv[2:])
        self.run()

    def start_progressbar(self, filename, size):
        if not HAS_PROGRESSBAR:
            return
        widgets = [
            filename, ' ', progressbar.Bar(), ' ',
            progressbar.FileTransferSpeed(), ' | ', progressbar.Percentage(),
            ' ',  progressbar.ETA()
        ]
        self.progressbar = progressbar.ProgressBar(widgets=widgets, maxval=size)
        self.progressbar.start()

    def finish_progressbar(self):
        if HAS_PROGRESSBAR:
            self.progressbar.finish()

    def progress(self, current, total):
        if HAS_PROGRESSBAR:
            self.progressbar.update(current)


class CreateCommand(Command):
    """
    bkt create [options] <bucket> [...]

    Creates a new bucket.

    Options:
        -l, --location LOC       The location in which to create the bucket
    """
    name = 'create'
    alias = ('mk',)

    def __init__(self):
        super(CreateCommand, self).__init__()

        # custom --location option
        self.parser.add_option('-l', '--location', dest='location',
                               default=self.location)

    def run(self):
        if len(self.args) < 1:
            self.help()

        for bucket in self.args:
            try:
                self.conn.create_bucket(bucket, location=self.options.location)
            except (S3CreateError, S3ResponseError) as e:
                self.error(e.error_message)


class GetCommand(Command):
    """
    bkt get <bucket> <file> [...]

    Get files from a bucket.
    """
    name = 'get'

    def run(self):
        if len(self.args) < 2:
            self.help()

        try:
            bucket = self.conn.get_bucket(self.args[0])
        except S3ResponseError as e:
            self.error(e.error_message)

        for fn in self.args[1:]:
            key = bucket.get_key(fn)
            if not key:
                self.error("The specified file does not exist in this bucket")

            try:
                self.start_progressbar(fn, key.size)
                fn = os.path.join(os.getcwd(), fn)
                fh = open(fn, 'w')
                key.get_file(fh, cb=self.progress, num_cb=100)
                self.finish_progressbar()
            except IOError:
                self.error("Could not write to local file '%s'" % fn)


class LsCommand(Command):
    """
    bkt ls [<bucket>]

    Lists all buckets or all files in a given bucket.
    """
    name = 'ls'
    alias = ('list',)

    def __init__(self):
        super(LsCommand, self).__init__()


    def run(self):
        if len(self.args) not in (0, 1):
            self.help()

        # listing all buckets
        if len(self.args) == 0:
            buckets = self.conn.get_all_buckets()
            for b in buckets:
                sys.stdout.write(b.name + '\n')
        else:
            try:
                bucket = self.conn.get_bucket(self.args[0])
                for key in bucket.list():
                    sys.stdout.write(key.name + '\n')
            except S3ResponseError as e:
                self.error(e.error_message)


class RmCommand(Command):
    """
    bkt rm <bucket> [<file> ...]

    Deletes a bucket or a file from a bucket.
    """
    name = 'rm'

    def run(self):
        if len(self.args) < 1:
            self.help()

        bucket = self.args[0]

        try:
            bucket = self.conn.get_bucket(bucket)
            if len(self.args) == 1:
                self.conn.delete_bucket(bucket)
            else:
                for fn in self.args[1:]:
                    bucket.delete_key(fn)
        except S3ResponseError as e:
            self.error(e.error_message)


class PutCommand(Command):
    """
    bkt put <bucket> <file> [...]

    Uploads a new file to a bucket.
    """
    name = 'put'

    def run(self):
        if len(self.args) < 2:
            self.help()

        try:
            bucket = self.conn.get_bucket(self.args[0])
            for fn in self.args[1:]:
                size = os.stat(fn).st_size
                key = Key(bucket)
                key.name = os.path.basename(fn)
                self.start_progressbar(fn, size)
                key.set_contents_from_filename(fn, cb=self.progress, num_cb=100)
                self.finish_progressbar()
        except S3ResponseError as e:
            self.error(e.error_message)


class CopyCommand(Command):
    """
    bkt cp <src> <filename> <dest> [<newfilename>]

    Copy a file to another bucket.
    """
    name = 'cp'
    alias = ('copy',)

    def run(self):
        if len(self.args) < 3:
            self.help()

        src, filename, dest = self.args[0:3]
        if len(self.args) == 4:
            newname = self.args[3]
        else:
            newname = filename

        try:
            bucket = self.conn.get_bucket(src)
            key = bucket.get_key(filename)
            if not key:
                self.error('Unknown file "%s"' % filename)
            key.copy(dest, newname)
        except S3ResponseError as e:
            self.error(e.error_message)


class MoveCommand(Command):
    """
    bkt mv <src> <filename> <dest> [<newfilename>]

    Move a file to another bucket.
    """
    name = 'mv'
    alias = ('move',)

    def run(self):
        if len(self.args) < 3:
            self.help()

        src, filename, dest = self.args[0:3]
        if len(self.args) == 4:
            newname = self.args[3]
        else:
            newname = filename

        try:
            bucket = self.conn.get_bucket(src)
            key = bucket.get_key(filename)
            if not key:
                self.error('Unknown file "%s"' % filename)
            key.copy(dest, newname)
            key.delete()
        except S3ResponseError as e:
            self.error(e.error_message)



if __name__ == '__main__':
    # no commands or arguments, print the help message
    if len(sys.argv) <= 1 or sys.argv[1] in ('-h', '--help', 'help'):
        sys.stderr.write(__doc__.lstrip())
        sys.exit()

    for c in Command.__subclasses__():
        if c.name == sys.argv[1] or hasattr(c, 'alias') and sys.argv[1] in c.alias:
            command = c()
            command.main()
            sys.exit()

    sys.stderr.write("Unknown command '%s'.\n" % sys.argv[1])
    sys.exit(1)
