#!/usr/bin/env python
"""
Usage: bkt <command> [options]

bkt handles file uploads to S3.

Commands:
  ls             List all buckets or all files in a bucket
  get            Download a file from a bucket
  mk             Create a new bucket
  put            Upload a file to a bucket
  rm             Delete a bucket or a file from a bucket
"""
import os
import re
import subprocess
import sys

try:
    import configparser
except ImportError:
    import ConfigParser as configparser

from boto.exception import S3CreateError, S3ResponseError
from boto.s3.connection import S3Connection
from boto.s3.key import Key


class Command(object):

    CONFIG_FILE = '~/.bkt'

    def __init__(self):
        self.setup_config()
        self.setup_auth()

        self.args = sys.argv[2:]
        self.conn = S3Connection(self.access_key, self.secret_key)

    def setup_auth(self):
        self.access_key = None
        self.secret_key = None

        for option in ['access_key', 'secret_key']:
            # try to get the regular options
            if self.config.has_option('auth', option):
                value = self.config.get('auth', option)
                setattr(self, option, value)

            # try to get the `_eval` option
            if self.config.has_option('auth', option + '_eval'):
                opt_eval = self.config.get('auth', option + '_eval')
                value = self.eval_option(opt_eval)
                setattr(self, option, value)

            if getattr(self, option, None) is None:
                self.error("Missing config option '%s'." % option)

    def setup_config(self):
        try:
            self.config = configparser.ConfigParser()
            self.config.readfp(open(os.path.expanduser(self.CONFIG_FILE)))
        except IOError:
            self.error("Couldn't read your config file.")

    def eval_option(self, cmd):
        proc = subprocess.Popen(cmd.split(), stdout=subprocess.PIPE)
        return proc.communicate()[0].strip()

    def error(self, msg, error=1):
        sys.stderr.write('bkt: %s\n' % msg)
        sys.exit(error)

    def help(self, *args, **kwargs):
        """
        Prints the help message to stderr.
        """
        output = ""
        for line in self.__doc__.strip().split("\n"):
            output += re.sub('^\s{4}', '', line) + "\n"
        sys.stderr.write('Usage: %s\n' % output.strip())
        sys.exit()

    def pbar(self, cur, total):
        """
        A very simple progress bar.
        """
        sys.stderr.write(str(cur * 100 / total) + "%\r")
        sys.stderr.flush()


class CreateCommand(Command):
    """
    bkt create <bucket> [...]

    Creates a new bucket.
    """
    name = 'create'
    alias = ('mk',)

    def run(self):
        if len(self.args) < 1:
            self.help()

        for bucket in self.args:
            try:
                self.conn.create_bucket(bucket, location=self.options.location)
            except (S3CreateError, S3ResponseError) as e:
                self.error(e.error_message)


class GetCommand(Command):
    """
    bkt get <bucket> <file> [...]

    Get files from a bucket.
    """
    name = 'get'
    alias = ('download',)

    def run(self):
        if len(self.args) < 2:
            self.help()

        try:
            bucket = self.conn.get_bucket(self.args[0])
        except S3ResponseError as e:
            self.error(e.error_message)

        for fn in self.args[1:]:
            key = bucket.get_key(fn)
            if not key:
                self.error("The specified file does not exist in this bucket")

            try:
                fn = os.path.join(os.getcwd(), fn)
                fh = open(fn, 'w')
                key.get_file(fh, cb=self.pbar)
            except IOError:
                self.error("Could not write to local file '%s'" % fn)


class LsCommand(Command):
    """
    bkt ls [<bucket>]

    Lists all buckets or all files in a given bucket.
    """
    name = 'ls'
    alias = ('list',)

    def run(self):
        if len(self.args) not in (0, 1):
            self.help()

        # listing all buckets
        if len(self.args) == 0:
            buckets = self.conn.get_all_buckets()
            for b in buckets:
                sys.stdout.write(b.name + '\n')
        else:
            try:
                bucket = self.conn.get_bucket(self.args[0])
                for key in bucket.list():
                    sys.stdout.write(key.name + '\n')
            except S3ResponseError as e:
                self.error(e.error_message)


class RmCommand(Command):
    """
    bkt rm <bucket> [<file> ...]

    Deletes a bucket or a file from a bucket.
    """
    name = 'rm'
    alias = ('delete',)

    def run(self):
        if len(self.args) < 1:
            self.help()

        try:
            bucket = self.conn.get_bucket(self.args[0])
            if len(self.args) == 1:
                self.conn.delete_bucket(self.args[0])
            else:
                for fn in self.args[1:]:
                    bucket.delete_key(fn)
        except S3ResponseError as e:
            self.error(e.error_message)


class PutCommand(Command):
    """
    bkt put <bucket> <file> [...]

    Uploads a new file to a bucket.
    """
    name = 'put'
    alias = ('upload',)

    def run(self):
        if len(self.args) < 2:
            self.help()

        try:
            bucket = self.conn.get_bucket(self.args[0])
            for fn in self.args[1:]:
                key = Key(bucket)
                key.name = os.path.basename(fn)
                key.set_contents_from_filename(fn, cb=self.pbar, num_cb=100)
        except S3ResponseError as e:
            self.error(e.error_message)


if __name__ == '__main__':
    # no commands or arguments, print the help message
    if len(sys.argv) <= 1 or sys.argv[1] in ('-h', '--help', 'help'):
        sys.stderr.write(__doc__.lstrip())
        sys.exit()

    for c in Command.__subclasses__():
        if c.name == sys.argv[1] or sys.argv[1] in c.alias:
            command = c()
            command.run()
            sys.exit()

    sys.stderr.write("Unknown command '%s'.\n" % sys.argv[1])
    sys.exit(1)
